name: CI

on:
  pull_request:
    paths-ignore:
      - '**.md'
  workflow_dispatch:
    inputs:
      PUBLISH:
        type: boolean
        description: Publish dated images and update the 'latest' tag?
        default: false
        required: false

  schedule:
    - cron: '30 9 * * *'  # Pacific Time 01:30 AM in UTC

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

permissions:
  contents: read  # to fetch code
  actions:  write # to cancel previous workflows
  packages: write # to upload container

jobs:
  metadata:
    runs-on: ubuntu-22.04
    outputs:
      BUILD_DATE: ${{ steps.date.outputs.BUILD_DATE }}
      PUBLISH: ${{ steps.if-publish.outputs.PUBLISH }}
    steps:
      - name: Set build date
        id: date
        shell: bash -x -e {0}
        run: |
          BUILD_DATE=$(TZ='US/Los_Angeles' date '+%Y-%m-%d')
          echo "BUILD_DATE=${BUILD_DATE}" >> $GITHUB_OUTPUT

      - name: Determine whether results will be 'published'
        id: if-publish
        shell: bash -x -e {0}
        run: |
          echo "PUBLISH=${{ github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.PUBLISH) }}" >> $GITHUB_OUTPUT

  amd64:
    needs: metadata
    uses: ./.github/workflows/_ci.yaml
    with:
      ARCHITECTURE: amd64
    secrets: inherit
 
  arm64:
    needs: metadata
    uses: ./.github/workflows/_ci.yaml
    with:
      ARCHITECTURE: arm64
    secrets: inherit

  publish-mealkit:
    needs: [metadata, amd64, arm64]
    if: (!cancelled()) && needs.metadata.outputs.PUBLISH
    strategy:
      fail-fast: false
      matrix:
        include:
          - TAG: JAX
            TARGET_IMAGE: jax
          - TAG: PALLAS
            TARGET_IMAGE: pallas
          - TAG: UPSTREAM_PAX
            TARGET_IMAGE: upstream-pax
          - TAG: UPSTREAM_T5X
            TARGET_IMAGE: upstream-t5x
          - TAG: PAX
            TARGET_IMAGE: pax
          - TAG: T5X
            TARGET_IMAGE: t5x
    uses: ./.github/workflows/_publish_container.yaml
    with:
      SOURCE_IMAGE: |
        ${{ fromJson(needs.amd64.outputs.ALL_TAGS)[format('TAG_{0}_MEALKIT', matrix.TAG)] }}
        ${{ fromJson(needs.arm64.outputs.ALL_TAGS)[format('TAG_{0}_MEALKIT', matrix.TAG)] }}
      TARGET_IMAGE: ${{ matrix.TARGET_IMAGE }}
      TARGET_TAGS: |
        type=raw,value=mealkit,priority=500
        type=raw,value=mealkit-${{ needs.metadata.outputs.BUILD_DATE }},priority=500

  publish-final:
    needs: [metadata, amd64, arm64]
    if: (!cancelled()) && needs.metadata.outputs.PUBLISH
    strategy:
      fail-fast: false
      matrix:
        include:
          - TAG: JAX
            TARGET_IMAGE: jax
          - TAG: PALLAS
            TARGET_IMAGE: pallas
          - TAG: UPSTREAM_PAX
            TARGET_IMAGE: upstream-pax
          - TAG: UPSTREAM_T5X
            TARGET_IMAGE: upstream-t5x
          - TAG: PAX
            TARGET_IMAGE: pax
          - TAG: T5X
            TARGET_IMAGE: t5x
    uses: ./.github/workflows/_publish_container.yaml
    with:
      SOURCE_IMAGE: |
        ${{ fromJson(needs.amd64.outputs.ALL_TAGS)[format('TAG_{0}_FINAL', matrix.TAG)] }}
        ${{ fromJson(needs.arm64.outputs.ALL_TAGS)[format('TAG_{0}_FINAL', matrix.TAG)] }}
      TARGET_IMAGE: ${{ matrix.TARGET_IMAGE }}
      TARGET_TAGS: |
        type=raw,value=latest,priority=500
        type=raw,value=nightly-${{ needs.metadata.outputs.BUILD_DATE }},priority=500

  finalize:
    runs-on: ubuntu-22.04
    needs: [metadata, amd64, arm64]
    if: "!cancelled()"
    env:
      # Name/bash regex for shields.io endpoint JSON files
      BADGE_FILES: '*badge*.json'
    outputs:
      GIST_ID: ${{ steps.extract-id.outputs.GIST_ID }}
    steps:
  #     - name: Generate job summary for container build
  #       shell: bash -x -e {0}
  #       run: |
  #         cat > $GITHUB_STEP_SUMMARY << EOF
  #         # Images created

  #         | Image        | Link                                               |
  #         | ------------ | -------------------------------------------------- |
  #         | Base         | ${{ needs.amd64.outputs.TAG_BASE }}                |
  #         |              | ${{ needs.arm64.outputs.TAG_BASE }}                |
  #         | JAX          | ${{ needs.amd64.outputs.TAG_JAX }}                 |
  #         |              | ${{ needs.arm64.outputs.TAG_JAX }}                 |
  #         | T5X          | ${{ needs.amd64.outputs.TAG_T5X }}                 |
  #         |              | ${{ needs.arm64.outputs.TAG_T5X }}                 |
  #         | PAX          | ${{ needs.amd64.outputs.TAG_PAX }}                 |
  #         |              | ${{ needs.arm64.outputs.TAG_PAX }}                 |
  #         EOF

  #         # | ROSETTA(t5x) | ${{ needs.build-rosetta-t5x.outputs.DOCKER_TAGS }} |
  #         # | ROSETTA(pax) | ${{ needs.build-rosetta-pax.outputs.DOCKER_TAGS }} |
      # upload badge
      - name: Download artifacts specified by input
        uses: actions/download-artifact@v3

      - name: Collect all badge files to temporary folder
        id: collect
        shell: bash -x -e {0}
        run: |
          workdir=$(mktemp -d)
          find -name "${BADGE_FILES}" | while read -s f; do
            cp "$f" $workdir
          done
          echo "WORKDIR=$workdir" >> $GITHUB_OUTPUT

      - name: Upload badge files to gist
        id: upload
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.NVJAX_GIST_TOKEN }}
          script: |
            const currentDateTime = new Date().toISOString();
            const gistDescription =
              `Badge endpoint files from Workflow: ${{ github.workflow }}, ` +
              `Run ID: ${{ github.run_id }}, ` +
              `Repository: ${{ github.repository }}, ` +
              `Event: ${{ github.event_name }}, ` +
              `Created: ${currentDateTime}`;

            const fs = require('fs').promises;
            const workdir = '${{ steps.collect.outputs.WORKDIR }}'
            const files = await fs.readdir(workdir);

            gist = await github.rest.gists.create({
              description: gistDescription,
              public: false,
              files: Object.fromEntries(
                await Promise.all(
                  files.map(
                    async filename => {
                      const content = await fs.readFile(`${workdir}/${filename}`, 'utf8');
                      return [filename, { content }];
                    }
                  )
                )
              )
            });

            console.log(gist)

            return gist.data.id;
      - name: Return Gist ID
        id: extract-id
        shell: bash -x -e {0}
        run: |
          GIST_ID="${{ steps.upload.outputs.result }}"
          echo "GIST_ID=${GIST_ID//\"/}" >> $GITHUB_OUTPUT
      
      # report 
      - name: Write output to step summary
        shell: bash -x -e {0}
        run: |
          find -name "sitrep.json" | while read -s f; do
            cat "$f" | jq -r '.summary' | tee -a $GITHUB_STEP_SUMMARY
          done

      # - name: Concatenate all sitreps
      #   shell: bash -x -e {0}
      #   run: |
      #     # combine all sitreps files into a single file, where each sitrep json sits
      #     # in a field named by the folder that contained it

      #     find -name "sitrep.json" | while read -s f; do
      #       echo "$(dirname $f): $(cat $f)," >>
      #     done

      # publish badge
      - name: copy badge to primary Gist
        if: needs.metadata.outputs.PUBLISH == true
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.NVJAX_GIST_TOKEN }}
          script: |
            const srcId = "${{ steps.extract-id.outputs.GIST_ID }}";
            const dstId = "${{ vars.BADGE_ENDPOINT_GIST_ID }}";
            const { BADGE_FILES } = process.env;

            // Fetch files from source gist
            const { data: srcData } = await github.rest.gists.get({
              gist_id: srcId
            });

            // Prepare file upload
            let filesToUpdate = {};
            pattern = new RegExp(`${BADGE_FILES}`);
            for (const [filename, fileObj] of Object.entries(srcData.files)) {
              if (filename.match(pattern)) {
                filesToUpdate[filename] = {
                  content: fileObj.content
                };
              }
            }

            // Update files in destination gist
            await github.rest.gists.update({
              gist_id: dstId,
              files: filesToUpdate
            });
            console.log("Files copied successfully.");
            console.log(Object.keys(filesToUpdate));