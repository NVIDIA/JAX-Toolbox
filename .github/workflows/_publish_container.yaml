name: ~publish images from internal to public repo

on:
  workflow_call:
    inputs:
      TARGET_IMAGE:
        type: string
        description: 'Target docker image (jax/t5x/etc.):'
        required: true
      TARGET_TAGS:
        type: string
        description: 'Target docker tags in docker/metadata-action format:'
        required: true
      SOURCE_IMAGE:
        type: string
        description: 'Source docker image:'
        required: true
      # EXPOSE_SINGLE_ARCH_IMAGES:
      #   type: boolean
      #   description: 'Also expose single-arch images:'
      #   required: false
      #   default: false
    outputs:
      DOCKER_TAGS:
        description: "Tags of the image published"
        value: ${{ jobs.publish.outputs.DOCKER_TAGS }}

env:
  DOCKER_REGISTRY: 'ghcr.io/nvidia'

jobs:
  publish:
    runs-on: ubuntu-22.04
    outputs:
      DOCKER_TAGS: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Convert escape characters in input string
        id: parse
        shell: bash -x -e {0}
        run: |
          echo "target_image=${{ inputs.TARGET_IMAGE }}" | tee -a $GITHUB_OUTPUT
          echo -e "target_tags=${{ inputs.TARGET_TAGS }}" | sed "s/$/%0A/g" | tee -a $GITHUB_OUTPUT
          echo -e "source_image=${{ inputs.SOURCE_IMAGE }}" | sed "s/$/%0A/g" | tee -a $GITHUB_OUTPUT

      - name: Set docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ steps.parse.outputs.target_image }}
          flavor: latest=false
          tags: ${{ steps.parse.outputs.target_tags }}

      - name: Extract manifests from the source manifest list
        id: get-manifests
        shell: bash -x -e {0}
        run: |
          manifests=""
          for src_img in $(echo "${{ steps.parse.outputs.source_image }}" | tr '\n' ' '); do
            repo=$(echo $src_img | cut -d: -f1)
            media_type=$(docker manifest inspect $src_img | jq -r '.mediaType')
            case "$media_type" in
              
              # OCI image index
              "application/vnd.oci.image.index.v1+json")
                manifest=$(
                  docker manifest inspect ${src_img} |\
                  jq -r '.manifests[] | select(.platform.os != "unknown") | .digest' |\
                  xargs -I{} echo ${repo}@{} |\
                  tr '\n' ' '
                )
                ;;

              # Docker image manifest
              "application/vnd.docker.distribution.manifest.v2+json")
                manifest=${src_img}
                ;;

              *)
                echo "Unknown media type: $MEDIA_TYPE"
                exit 1
                ;;
            esac
            manifests="$manifests $manifest"
          done

          echo "manifests=$manifests" >> $GITHUB_OUTPUT

      - name: Create multi-arch images
        id: multi-arch
        shell: bash -x -e {0}
        run: |
          for tag in $(echo "${{ steps.meta.outputs.tags }}"); do
            docker buildx imagetools create --tag $tag ${{ steps.get-manifests.outputs.manifests }}
          done

      # - name: Create single-arch images
      #   if: ${{ inputs.EXPOSE_SINGLE_ARCH_IMAGES }}
      #   shell: bash -x -e {0}
      #   run: |
      #     # Create new manifest list from extracted manifests
      #     for manifest in ${{ steps.get-manifests.outputs.manifests }}; do
      #       os=$(docker manifest inspect -v $manifest | jq -r '.Descriptor.platform.os')
      #       arch=$(docker manifest inspect -v $manifest | jq -r '.Descriptor.platform.architecture')
      #       for tag in $(echo "${{ steps.meta.outputs.tags }}"); do
      #         skopeo copy --format v2s2 docker://$manifest docker://$tag-${os}-${arch}
      #       done
      #     done
